

The easiest way to explain Ironclad's inner workings is to follow the code as we import and use the bz2 module; the following code is lightly adapted from 'tests/functionalitytest.py', and assumes the existence of a helpful 'Execute' function for running the actual code (see 'tests/data/src/executils.cs' for an example).

------------------------------------------------------------------------------------------------
mapper = Python25Mapper()
sr = StubReference("python25.dll")
try:
    sr.Init(AddressGetterDelegate(mapper.GetAddress), DataSetterDelegate(mapper.SetData))
    pi = PydImporter()
    pi.Load("C:\\Python25\\Dlls\\bz2.pyd")
    try:
        Execute(mapper.Engine, "import bz2")
        Execute(mapper.Engine, "print bz2.compress('heaps and heaps of data ' * 200)")
    finally:
        pi.Dispose()
finally:
    sr.Dispose()
------------------------------------------------------------------------------------------------

The first lines requires little explanation -- we create an Ironclad Python25Mapper which, in the absence of extra arguments, creates its own ScriptEngine. Broadly speaking, the Python25Mapper is responsible for updating the IronPython state in response to CPython API calls, and for allocating and keeping track of CPython objects; we'll discuss it in more detail shortly. The 2nd line is more interesting.

------------------------------------------------------------------------------------------------
sr = StubReference("python25.dll")
------------------------------------------------------------------------------------------------

We pass the StubReference the path to our autogenerated stub library. This library exports all the symbols exported by the real python25 library, and has the same name; once we've loaded it, our process space contains a library that looks very much like the real python25. As yet, it contains very little of value -- any function calls or attempts to access data will almost certainly crash. To make it useful, we need to initialise it:

------------------------------------------------------------------------------------------------
    sr.Init(AddressGetterDelegate(mapper.GetAddress), DataSetterDelegate(mapper.SetData))
------------------------------------------------------------------------------------------------

The 'Init' method takes a pair of Delegates, converts them to function pointers, and passes them into the stub python25's 'init' function:

------------------------------------------------------------------------------------------------
void init(void*(*address_getter)(char*), void(*data_setter)(char*, void*))
------------------------------------------------------------------------------------------------

The stub dll exports all the same symbols as the real python25.dll, which fall into the following categories:

* Simple pointers -- the symbol points to a pointer-sized lump of memory in the library, which itself points to some actual data somewhere else.
* Function pointers -- the symbol points to an arbitrarily-sized lump of memory in the library, containing actual code.
* Static data -- the symbol points to an arbitrarily-sized lump of memory in the library, containing actual data.

In the first case -- simple pointers -- the Init method just calls address_getter with the symbol name, and writes the returned address into the memory referred to by the symbol. For example:

------------------------------------------------------------------------------------------------
    PyExc_OverflowError = address_getter("PyExc_OverflowError");
------------------------------------------------------------------------------------------------

Function pointers also use address_getter, because every function is implemented in assembler as a single JMP instruction; the target of this JMP is stored in a table whose contents are set according to the results of GetAddress calls. For example:

------------------------------------------------------------------------------------------------
    jumptable[649] = address_getter("Py_InitModule4");
------------------------------------------------------------------------------------------------

causes the following assembler code to correctly intercept a call to Py_InitModule4 and pass it up to managed code.
------------------------------------------------------------------------------------------------
_Py_InitModule4:
    jmp [_jumptable+2596]
------------------------------------------------------------------------------------------------

Finally, static data is initialised with the data_setter, which fills the referenced block of memory with appropriate data:

------------------------------------------------------------------------------------------------
    data_setter("PyFile_Type", &PyFile_Type);
------------------------------------------------------------------------------------------------

The stub python25's 'init' function calls either address_getter or data_setter for every symbol; how it chooses depends on the contents of the 'stub' directory, from which it was itself autogenerated. The details are not directly relevant to this discussion; if you're interested, read 'tools/stubmaker.py'.

Once the 'init' function returns, the stub library is ready for duty.

------------------------------------------------------------------------------------------------
    pi = PydImporter()
    pi.Load("C:\\Python25\\Dlls\\bz2.pyd")
------------------------------------------------------------------------------------------------

'PydImporter.Load' loads a library into the process space, and calls the appropriate initialisation function (which is always called 'init[modulename]'). Before we get into the details of what happens now, note that we keep a reference to the PydImporter, so it doesn't get garbage collected until we're ready: the Dispose method will unload any libraries it has imported.

When bz2.pyd's 'initbz2' function is called, it (almost immediately) calls the C 'Py_InitModule4' function. Because the process space already has a library called 'python25' containing the symbol 'Py_InitModule4', the code corresponding to that symbol is executed. This code is a single jmp instruction, leading to the function pointer that was returned by the call to GetAddress("Py_InitModule4") a few paragraphs ago. And... execution jumps to 'Python25Mapper.Py_InitModule4'.

The parameters include the CPython module's name and docstring, and a pointer to its method-names, -docstrings, and -implementations; we use this information to generate Python code which we execute in a new ScriptScope, giving it the appropriate properties (we'll take a look at this code a little bit later). We also create a dictionary mapping function names to delegates, which are themselves created from the function pointers to the actual implementations. This 'DispatchTable' dictionary is stored in the new module scope, as is a reference to the Python25Mapper object itself.

At this point, the new module is published, and it becomes possible to 'import bz2'; however, it still isn't very useful. Anyway, once we have created the new module, we pass it into the Python25Mapper's 'Store' method, which:
* allocates a tiny chunk of memory (enough to hold a refcount and a type pointer);
* stores the module in a dictionary, keyed on the pointer we just allocated; and
* returns the pointer.

'Py_InitModule4' then returns that pointer; 'initbz2' checks that the pointer is not NULL, and then uses it as the first parameter to a series of 'PyModule_AddObject' calls, which it uses to add the BZ2File, BZ2Compressor, and BZ2Decompressor types to the module. These calls are intercepted in the same way as before, so the parameters are passed up to the Python25Mapper's 'PyModule_AddObject' method.

The first parameter is always the pointer we allocated previously; the Python25Mapper's 'PyModule_AddObject' looks up this pointer in the dictionary and retrieves a reference to the real module, and then generates and executes some more code (in that module) to define the new types in such a way that IronPython can use them. Any methods defined on those types are also added to the module's DispatchTable.

Finally, 'PyModule_AddObject' extracts a reference to the newly-defined IronPython type, and sets various attributes on it, which are used by the generated code: specifically, these attributes are (1) a pointer to the PyTypeObject ('_typePtr') and (2) delegates pointing to the C functions which create and initialise instances of the type.

At this point, we can start doing interesting things with the module; to understand these, it will be useful to see (a representative sample of) the code that has been executed in the new module:

------------------------------------------------------------------------------------------------

def _cleanup(*args):
    _ironclad_mapper.FreeTemps()
    for arg in args:
        if arg != IntPtr.Zero:
            _ironclad_mapper.DecRef(arg)

def _raiseExceptionIfRequired():
    error = _ironclad_mapper.LastException
    if error:
        _ironclad_mapper.LastException = None
        raise error

...

def _ironclad_dispatch_kwargs(name, instancePtr, args, kwargs):
    argPtr = _ironclad_mapper.Store(args)
    kwargPtr = _ironclad_mapper.Store(kwargs)
    resultPtr = _ironclad_dispatch_table[name](instancePtr, argPtr, kwargPtr)
    try:
        _raiseExceptionIfRequired()
        return _ironclad_mapper.Retrieve(resultPtr)
    finally:
        _cleanup(argPtr, kwargPtr, resultPtr)
------------------------------------------------------------------------------------------------

The code just above is always included, and does most of the critical work. The '_ironclad_mapper' is the Python25Mapper that created the module, and the '_ironclad_dispatch_table' is a dictionary mapping function names to their C implementations (or rather, to delegates which point to the C implementations).

The only dispatch function shown here ('_ironclad_dispatch_kwargs') is the most complex of the those currently implemented; '_ironclad_dispatch', '_ironclad_dispatch_self' and '_ironclad_dispatch_noargs' are fundamentally similar. We'll describe how it actually works when we finally call 'bz2.compress' -- soon, I promise.

------------------------------------------------------------------------------------------------
def compress(*args, **kwargs):
    '''compress(data [, compresslevel=9]) -> string

Compress data in one shot. If you want to compress data sequentially,
use an instance of BZ2Compressor instead. The compresslevel parameter, if
given, must be a number between 1 and 9.
'''
    return _ironclad_dispatch_kwargs('compress', IntPtr.Zero, args, kwargs)
------------------------------------------------------------------------------------------------

The definition of the 'compress' function, above, was generated from the name and docstring in the PyMethodDef structure passed into 'Py_InitModule4'. So, what happens when we actually call it?

First of all, '_ironclad_dispatch_kwargs' gets pointers to the args and kwargs by passing them into the Python25Mapper's 'Store' method. As discussed previously, this method allocates a tiny bit of memory and maps it to the real object so we can retrieve the real object again when we need it. In the case of the kwargs dictionary, all we need to create is a tiny block of memory with a refcount and a type pointer; however, the contents of args tuple may be directly accessed by unmanaged code, so we lay the memory out correctly and fill it with sensible data in that case.

Then, it looks up the C function's delegate in the '_ironclad_dispatch_table' dictionary, and passes the newly-created pointers to the delegate; this then calls the 'bz2_compress' C function. The C function immediately calls 'PyArg_ParseTupleAndKeywords', which would be a horrible pain to implement in managed code; thankfully, the CPython version is implemented in terms of the rest of the CPython API, so we were able to copy the implementation directly.

Once 'PyArg_ParseTupleAndKeywords' returns, 'bz2_compress' has access to all its arguments in a format it can do real work with. I don't know what it's really doing under the hood; from our perspective, the only really important thing is that it creates a PyStringObject by calling 'PyString_FromStringAndSize', and eventually returns a pointer to that PyStringObject.

This PyString object, like the tuples mentioned previously, makes an attempt at impersonating a real PyStringObject: we actually lay the memory out correctly and put the character data in the right place. This is necessary because the function uses the PyString_AS_STRING macro, which returns a pointer to that character data, into which 'bz2compress' writes the compressed bytes.

Also, since the managed code doesn't know the string contents until 'bz2compress' has finished writing it, it doesn't create a managed string yet: rather, it maps the string pointer to an 'UnmanagedDataMarker.PyStringObject'. Once 'bz2compress' finally returns, '_ironclad_dispatch_kwargs' receives a pointer to the PyStringObject; when we 'Retrieve' the managed object from the Python25Mapper, it reads in the character data and replaces the marker in the pointer map before returning the actual managed string -- which is at last returned to the IronPython code which made the call to 'compress' in the first place.

Had anything gone wrong in the above process, a call to 'PyErr_SetString' would have set an exception on the Python25Mapper object; if the mapper's LastException property is non-None at the end of a call into unmanaged code, we raise the exception and clear the property. We also ensure that we decref argPtr, kwargPtr, and resultPtr before we return, to avoid leaking memory.

Phew. Now, let's look at the 'BZ2Compressor' type. Thankfully, given the context we have already built up, this should be relatively easy to describe. Here's the code generated by the 'PyModule_AddObject' call which set it up:

------------------------------------------------------------------------------------------------
class BZ2Compressor(object):
    __module__ = 'bz2'
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)
        argPtr = _ironclad_mapper.Store(args)
        kwargPtr = _ironclad_mapper.Store(kwargs)
        try:
            instancePtr = cls._tp_newDgt(cls._typePtr, argPtr, kwargPtr)
            _raiseExceptionIfRequired()
        finally:
            _cleanup(argPtr, kwargPtr)

        _ironclad_mapper.StoreUnmanagedData(instancePtr, instance)
        instance._instancePtr = instancePtr
        return instance

    def __init__(self, *args, **kwargs):
        object.__init__(self)
        argPtr = _ironclad_mapper.Store(args)
        kwargPtr = _ironclad_mapper.Store(kwargs)
        try:
            result = self.__class__._tp_initDgt(self._instancePtr, argPtr, kwargPtr)
            if result == -1:
                _ironclad_mapper.DecRef(self._instancePtr)
            _raiseExceptionIfRequired()
        finally:
            _cleanup(argPtr, kwargPtr)

    def compress(self, *args):
        '''compress(data) -> string

Provide more data to the compressor object. It will return chunks of
compressed data whenever possible. When you've finished providing data
to compress, call the flush() method to finish the compression process,
and return what is left in the internal buffers.
'''
        return _ironclad_dispatch('BZ2Compressor.compress', self._instancePtr, args)

    def flush(self):
        '''flush() -> string

Finish the compression process and return what is left in internal buffers.
You must not use the compressor object after calling this method.
'''
        return _ironclad_dispatch_noargs('BZ2Compressor.flush', self._instancePtr)

BZ2Compressor.__name__ = 'BZ2Compressor'
------------------------------------------------------------------------------------------------

The first thing to note is that the methods use the same dispatch functions as regular function calls, but where functions pass IntPtr.Zero, methods pass an actual instance pointer. Getting that instance pointer in the first place is slightly more interesting.

When you instantiate a BZ2Compressor, the __new__ method calls the CPython type's 'tp_new' function (via a delegate, with exception checking and parameter cleanup, as usual). As long as this function doesn't set an exception, we use 'StoreUnmanagedData' to set up the mapping in the Python25Mapper, give the instance a reference to the unmanaged memory backing it, and return the real managed object. 'StoreUnmanagedData' is just like 'Store' -- it causes the Python25Mapper to remember the relationship between the pointer and the object -- but it's used in cases where the unmanaged memory has already been allocated.

Similarly, the __init__ method calls the CPython type's 'tp_init' function in the usual fashion, passing in the recently-created instance pointer. The only potentially surprising feature is that, on failure, we decref the instance pointer; we suspect that this may cause problems if exceptions are raised when the same object is repeatedly initialised, but we've resolved not to worry about this for now.

We don't yet handle object deletion.

