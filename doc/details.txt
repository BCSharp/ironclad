This document is intended to give you a developer's-eye view of the project:
what we build, how we build it, what it's made of, and some vague idea of how 
the pieces work together. Feedback is actively solicited.


BUILD PRODUCTS

When the project has been successfully built, build/ironclad will contain four
files:

* python27.dll

This dll is built from the contents of the stub directory; it's written in C
and a little bit of asm, most of whch is autogenerated; however, several
large parts are copied directly from CPython itself. When it's loaded into a
process' address space it impersonates the real python27.dll and redirects
many CPython API calls into managed code.

* ic_msvcr90.dll

This dll is here to allow ironclad.dll to DllImport functions from 
msvcr90.dll. It's tedious and ugly but at least it's self-contained.

* ironclad.dll

This managed assembly contains "everything else" -- all the logic that isn't
already implemented in python27.dll, and all the parts that handle object
marshalling and suchlike.

* __init__.py

When imported, creates a PythonMapper object (and consequently sets up import 
hooks, object mapping, etc, sufficient to make everything work). Also contains 
a few mildly useful functions; check their docstrings.


CODE GENERATION

Templates are stored in data/snippets, subdivided by language: cs for C# code to
be compiled, py for Python code to execute at runtime, and stub for the C and ASM 
used to build python27.dll.

Scripts are stored in tools, and (apart from the trivial generateexports) share a 
common format: a list of inputs and outputs (which it would be cool to scan in 
SConstruct to get rid of tedious manual dependencies), and a call to a convenience 
function which takes a generator class and the inputs/outputs.

Some of the more interesting products follow:

* src/Delegates.Generated.cs

This file is autogenerated as a result of interactions between other code generators
ultimately invoked by tools/generateapiplumbing.py. It declares a single managed 
Delegate for every platform-unique function specification it's seen while generating 
the Dispatcher and PythonApi classes; eliding the distinction between ints and 
ssize_ts at this level is the only way to get C# to let us cast freely between 
equivalent delegate types.

You may not normally need to do this; however, in abnormal circumstances, it's a 
really useful feature, and the pain of not having it when you need it far outweighs 
the hassle of performing the canonicalisation in the first place.

* src/Dispatcher.Generated.cs

Dispatcher methods deal with the details of calling CPython functions, and getting 
and setting CPython object members. The input data is minimally dependent on the 
details of the CPython API: object translation and appropriate delegate types are 
determined from the GCCXML output (generated separately in SConstruct), while the
information in data.api concerns itself with a surprisingly small set of site-specific
tweaks.

* src/PythonApi.Generated.cs

Intent to implement an API function is registered by entering its name into 
data/api/_mgd_api_functions; PythonApi generation will automatically figure out what 
the correct signature is, and store delegates of the appropriate canonicalised type.

* src/PythonStructs.Generated.cs

For each entry in data/api/_mgd_api_structs, this file contains a C# structure 
definition generated from the GCCXML output. Somewhat sloppily analyzed: we assume
that fields of unrecognised types are just generic pointers.


INTERESTING CLASSES

* PythonApi (generated)

This class has a property for every piece of data we care about and a method 
for every function we care about, and maintains mappings from API names to 
pointers; it also defines the GetFuncPtr and RegisterData functions which are 
passed to the StubReference at dll init time.

* StubReference

Loads the redirection dll (python27.dll) and initialises it, passing function
pointers to GetFuncPtr and RegisterData. The init function calls these functions
repeatedly, passing in the names of the symbols it exports; once all the data
has been filled in, the redirection should work.

* PythonMapper (partly generated)

This class is big; really, really big. Also, ugly. It contains all the
implemented API functions; it's responsible for filling in all the uninitialised
data in the redirection dll; it maintains the 2-way mappings between managed
and unmanaged objects. It also holds a whole load of useful logic and data for
managing things like imports and errors; it should certainly be split up into
several smaller classes, but the dividing lines remain unclear. It also holds the 
Global Interpreter Lock, without which object destruction becomes exceedingly 
error-prone.

The generated code covers mappings for exception types, basic setup for builtin 
types, and various parts of the PyNumber API. It also covers the StoreDispatch 
method, which gets around C#'s irritatingly uncivilised compile-time method 
resolution.

* InterestingPtrMap

Stores the various kinds of managed and unmanaged data, and is responsible for
managing the lifetimes of 'bridge' objects (basically, any object whose 
unmanaged representation contains important state; specifically, objects with
unmanaged types, and PyCObjects). It does this by reading the ob_refcnt field
and maintaining either weak or strong references to the objects; if ob_refcnt
is greater than one, then some unmanaged code has a reference to the object and
we need to keep the managed object alive by keeping a strong reference to it in
the map. However, if ob_refcnt is one, the managed representation owns the only
reference to the unmanaged representation, and we can allow normal managed
garbage collection to take its course and destroy both representations at its
leisure.

It's worth noting that it maintains the mapping based on identity, rather than 
equality: this may occasionally lead to us storing more objects than we strictly 
need to, but it also prevents potentially costly code (__eq__ and __hash__)
being executed in the course of what should be simple bookkeeping.

The GCThreshold setting controls how frequently we update objects' reference
strengths and force garbage collection; it's accessible via the ironclad module's
set_gc_threshold function. Low values cause aggressive cleanup, and hence slower
execution; high values lead to faster execution, but may cause out-of-memory errors
if lots of large short-lived objects are being created.

* ClassBuilder

Generates IronPython code to create a class from a PyTypeObject pointer (and an
extra compatible type which allows for safe __class__ reassignment in the cases 
where C code creates -- or, at least, starts to create -- an object without using 
the C API directly). 

* CallableBuilder

Responsible for creating normal method code, and free function code, and is used 
both by ClassBuilder and by PythonMapper directly when reading PyMethodDefs in 
Py_InitModule4.

* Dispatcher (mostly generated)

This is a 90%-autogenerated C# class which uses the PythonMapper to translate
IronPython calls to CPython calls, and return the results as IronPython objects
(or raise exceptions as appropriate). All calls and memory accesses -- for all
objects and all functions -- are synchronised with the PythonMapper's GIL object.


BORING CLASSES

* PydImporter

Loads a .pyd file and calls its initialisation function. Everything else is taken
care of by API calls.

* HGlobalAllocator

Allocates, reallocates and deallocates unmanaged memory. Knows what pointers
it's responsible for. Not exciting, and we should probably use the CPython 
allocator anyway.

* CPyMarshal

Static utility class which simplifies reading and writing all sorts of unmanaged
data. Nothing to see here, move along.

* MagicMethods (generated)

Hardcoded method name mappings, used by ClassBuilder.

* Lock

It appears that System.Threading.Monitor has some problems when trying to lock on 
the same object from STA and MTA threads (see IronPython-users list, early Nov 2008). 
Win32 mutexen appear to have no such problem, so we use them instead.

* StupidSet

Essentially, a Dictionary<object, string> whose values are always "stupid"; much
like a python set, but capable of holding "unhashable" objects. Not very
interesting, and now only used in one place; would be good to get rid of it, since
it doesn't even need to hold unhashable objects now.

* InappropriateReflection

Static utility class for messing with other classes' privates. Yes, I'm ashamed.

* Counter

Does exactly what it says on the tin.

* ThreadState

Keeps track of per-thread exception state.

* Unmanaged

Static utility class, with DllImports of various useful functions from 
kernel32.dll and msvcr90.dll (the latter via ic_msvcr90.dll; read about
side-by-side assemblies if you want to know why that's neededs).
