This documentation originally went into an awful lot of unnecessary detail;
from r208 onwards it will just try to cover everything at a high level, and
leave the ever-changing details to those interested enough to read the
source.


Build products

A folder called 'ironclad', containing:

python26.dll

This dll is built from the contents of the stub directory; it's written in C
and a little bit of asm, most of whch is autogenerated; however, several
large parts are copied directly from CPython itself. When it's loaded into a
process' address space it impersonates the real python26.dll and redirects
many CPython API calls into managed code.

ironclad.dll

This managed assembly contains "everything else" -- all the logic that isn't
already implemented in python26.dll.

__init__.py

Importing this module will subsequently allow you to transparently import 
CPython extensions.


Interesting Classes

PythonApi

This class is generated from various files in stub/ and tools/. It has
a property for every piece of data in the API and a method for every function,
and maintains mappings from API names to pointers; it also defines the
GetFuncPtr and RegisterData functions which are passed to the StubReference.

StubReference

Loads the redirection dll (python26.dll) and initialises it, passing function
pointers to GetFuncPtr and RegisterData. The init function calls these functions
repeatedly, passing in the names of the symbols it exports; once all the data
has been filled in, the redirection should work.

PythonMapper

This class is big; really, really big. Also, ugly. It contains all the
implemented API functions; it's responsible for filling in all the uninitialised
data in the redirection dll; it maintains the 2-way mappings between managed
and unmanaged objects. It also holds a whole load of useful logic and data for
managing things like imports and errors; it should certainly be split up into
several smaller classes, but the dividing lines remain unclear. It also holds the 
Global Interpreter Lock, without which object destruction becomes exceedingly 
error-prone.

Some parts of this file are also generated from the contents of data/mapper,
specifically: mappings for exception types; basic setup for builtin types;
various parts of the PyNumber API; and, the StoreDispatch method which redirects 
calls to public Store(object obj) to private Store(actual-type-of-obj obj).

InterestingPtrMap

Stores the various kinds of managed and unmanaged data, and is responsible for
managing the lifetimes of 'bridge' objects (basically, any object whose 
unmanaged representation contains important state; specifically, objects with
unmanaged types, and PyCObjects). It does this by reading the ob_refcnt field
and maintaining either weak or strong references to the objects; if ob_refcnt
is greater than one, then some unmanaged code has a reference to the object and
we need to keep the managed object alive by keeping a strong reference to it in
the map. However, if ob_refcnt is one, the managed representation owns the only
reference to the unmanaged representation, and we can allow normal managed
garbage collection to take its course and destroy both representations at its
leisure.

It's worth noting that it maintains the mapping based on identity, rather than 
equality: this may occasionally lead to us storing more objects than we strictly 
need to, but it also prevents potentially costly code (__eq__ and __hash__)
being executed in the course of what should be simple bookkeeping.

The GCThreshold setting controls how frequently we update objects' reference
strengths and force garbage collection; it's accessible via the ironclad module's
set_gc_threshold function. Low values cause aggressive cleanup, and hence slower
execution; high values lead to faster execution, but may cause out-of-memory errors
if lots of large short-lived objects are being created.

ClassBuilder

Generates IronPython code to create a class from a PyTypeObject pointer (and an
extra compatible type which allows for safe __class__ reassignment in the cases 
where C code creates -- or, at least, starts to create -- an object without using 
the C API directly). 

CallableBuilder

Responsible for creating normal method code, and free function code, and is used 
both by ClassBuilder and by PythonMapper directly when reading PyMethodDefs in 
Py_InitModule4.

Dispatcher

This is a 90%-autogenerated C# class which uses the PythonMapper to translate
IronPython calls to CPython calls, and return the results as IronPython objects
(or raise exceptions as appropriate). All calls and memory accesses -- for all
objects and all functions -- are synchronised with the PythonMapper's GIL object.


Boring classes

PydImporter

Loads a .pyd file and calls its initialisation function. Everything else is taken
care of by API calls.

HGlobalAllocator

Allocates, reallocates and deallocates unmanaged memory. Knows what pointers
it's responsible for. Not exciting, and we should probably use the CPython 
allocator anyway.

CPyMarshal

Static utility class which simplifies reading and writing all sorts of unmanaged
data. Nothing to see here, move along.

MagicMethods

Hardcoded method name mappings, used by ClassBuilder. Autogenerated from tools/.

Lock

It appears that System.Threading.Monitor has some problems when trying to lock on 
the same object from STA and MTA threads (see IronPython-users list, early Nov 2008). 
Win32 mutexen appear to have no such problem, so we use them instead.

StupidSet

Essentially, a Dictionary<object, string> whose values are always "stupid"; much
like a python set, but capable of holding "unhashable" objects. Not very
interesting, but used in several places.

InappropriateReflection

Static utility class for messing with other classes' privates. Yes, I'm ashamed.

ThreadLocalCounter/ThreadLocalDict

Definite candidates for refactoring. Names describe intended use, but nothing 
they do is specifically thread local; really, the thread-locality should be
handled inside these classes instead of by the client, and then they'd (1) be 
useful and (2) do what they say on the tin.

Unmanaged

Static utility class, with DllImports of various useful functions from 
kernel32.dll and msvcr71.dll.


Other things

PythonStructs.cs contains memory layouts for various CPython objects. I fear 
the day when we have to deal with 64-bit machines; I wish C# had typedefs. In 
the long term, a C# preprocessor is, sadly, on the cards.



