

Overview

PROJECTNAME's purpose is to allow IronPython to transparently import and use compiled CPython extensions. Currently, it only works on 32-bit Windows, although we are trying to avoid using too much platform-specific code: we would very much like to make PROJECTNAME work on Mono as well. It contains two major components:

* A stub library which impersonates CPython, autogenerated from (1) the compiled Python library and (2) various snippets of C code located in the 'overrides' directory;

* A CLR assembly which loads and initialises the stub, so that subsequent CPython API calls affect the state of an IronPython PythonEngine. The vast majority of the work is done by a subclass of the autogenerated PythonMapper class.


Status

* Once bz2.pyd has been loaded, it is possible to import the Python 2.5 bz2 module; all its functions, types, and strings are accessible from IronPython. See 'functionalitytest.py' for an example.

* The 'compress' and 'decompress' functions, and the 'BZ2Compressor' and 'BZ2Decompressor' types, appear to work correctly.

* It is not currently possible to instantiate the 'BZ2File' type; this is the reason that functionalitytest.testBZ2File fails. All other tests should pass.

* In general, nothing not explicitly mentioned above will work.

* It may be possible to import some other CPython extensions without crashing.

* If you're exceptionally lucky, it may be possible to actually use parts of other CPython extensions.

* Is is not possible to use more than one StubReference in a given process, and we see no way around this limitation; since modules can be shared between PythonEngine instances, this should not present insurmountable problems, but should be borne in mind.


Immediate next steps

* Implement 'Py_VaBuildValue' (and related functions) using code from 'modsupport.c' in the CPython source.
** This is desirable because these functions appear to be implemented in terms of other CPython API functions which will be useful elsewhere (PyString_FromStringAndSize, PyInt_FromLong, etc). Also, marshalling varargs is not fun, and this lets us dodge the issue.
** Doing this correctly will involve a new build stage: basically, we need to configure the CPython source for the current machine, and preprocess the borrowed code, so that we can drop it into the stub library as an override. This will be useful for borrowing more code from CPython as work progresses, and autogenerating C# files to make them reusable across different architectures.

* Implement 'PyObject_CallFunction' using code from 'abstract.c' in the CPython source (this uses Py_VaBuildValue).
** This step will allow us to get slightly further with instantiation of 'BZ2File' objects.

* Implement 'PyFile_AsFile', which will allow us to complete instantiation of 'BZ2File' objects.

* Implement whatever else we need to allow us to run 'testbz2.py' and have it all pass.


Useful imminent steps

* Reimplement the PyArg_ family of functions using code from 'getargs.c' in the CPython source.

* Add null implementations of all CPython API functions, which simply log that they have been called and (where appropriate) return an error value, so that we can quickly diagnose problems importing new extensions.

* Change 'generatepythonmapper.py' to store exception type pointers as properties on PythonMapper objects, and somehow map them to appropriate CLR exceptions; once this is done, it will be possible to usefully implement the PyErr_Set functions.


For the future

* Start work on numpy.
