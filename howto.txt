

The easiest way to explain Ironclad's inner workings is to follow the code as we import and use the bz2 module; the following code is lightly adapted from 'functionalitytest.py'.

------------------------------------------------------------------------------------------------
engine = PythonEngine()
mapper = Python25Mapper(engine)
sr = StubReference("python25.dll")
try:
	sr.Init(AddressGetterDelegate(mapper.GetAddress), DataSetterDelegate(mapper.SetData))
	pi = PydImporter()
	pi.Load("C:\\Python25\\Dlls\\bz2.pyd")
	try:
		engine.Execute("import bz2")
		engine.Execute("print bz2.compress('heaps and heaps of data ' * 200)")
	finally:
		pi.Dispose()
finally:
	sr.Dispose()
------------------------------------------------------------------------------------------------

The first 2 lines require little explanation -- we create an IronPython PythonEngine and a Ironclad Python25Mapper, and give the latter a reference to the former. Broadly speaking, the Python25Mapper is responsible for updating the IronPython state in response to CPython API calls, and for allocating and keeping track of CPython objects; we'll discuss it in more detail shortly.

On the 3rd line, things start to get interesting.

------------------------------------------------------------------------------------------------
sr = StubReference("python25.dll")
------------------------------------------------------------------------------------------------

We pass the StubReference the path to our autogenerated stub library. This library exports all the symbols exported by the real python25 library, and has the same name; once we've loaded it, our process space contains a library that looks very much like the real python25. As yet, it contains very little of value -- any function calls or attempts to access data will almost certainly crash. To make it useful, we need to initialise it:

------------------------------------------------------------------------------------------------
	sr.Init(AddressGetterDelegate(mapper.GetAddress), DataSetterDelegate(mapper.SetData))
------------------------------------------------------------------------------------------------

The 'Init' method takes a pair of Delegates, converts them to function pointers, and passes them into the stub python25's 'init' function.

'GetAddress' is defined in the autogenerated PythonMapper base class; it takes a symbol (as a string) and returns a function pointer. This function pointer comes from a delegate of the appropriate type, which itself delegates to the real managed implementation of that function (that is, a method on the PythonMapper instance). The delegate is stored, to avoid embarrassing garbage collections and consequent crashes.

'SetData', also in the autogenerated PythonMapper, takes a symbol and an address, and calls a method on the PythonMapper which will write data into that address; this is primarily for Py*_Types, which are exported as blocks of static data (rather than pointers). At the moment, none of these are actually implemented. Here's a small block of the autogenerated 'init' function:

------------------------------------------------------------------------------------------------
void init(void*(*address_getter)(char*), void(*data_setter)(char*, void*)) {
    ...
    data_setter("PyFile_Type", &PyFile_Type);
    ...
    jumptable[658] = address_getter("Py_InitModule4");
    ...
}
------------------------------------------------------------------------------------------------

The stub python25's 'init' function calls either GetAddress or SetData for every symbol; how it chooses depends on the contents of the 'overrides' directory, from which it was itself autogenerated. The details are not directly relevant to this discussion; if you're interested, read 'stubmaker.py'.

Once the 'init' function returns, the stub library is ready for duty.

------------------------------------------------------------------------------------------------
	pi = PydImporter()
	pi.Load("C:\\Python25\\Dlls\\bz2.pyd")
------------------------------------------------------------------------------------------------

'PydImporter.Load' loads a library into the process space, and calls the appropriate initialisation function (which is always called 'init[modulename]'). Before we get into the details of what happens now, note that we keep a reference to the PydImporter, so it doesn't get garbage collected until we're ready: the Dispose method will unload any libraries it has imported.

When bz2.pyd's 'initbz2' function is called, it (almost immediately) calls the C 'Py_InitModule4' function. Because the process space already has a library called 'python25' containing the symbol 'Py_InitModule4', the code corresponding to that symbol is executed. This code is a single jmp instruction, leading to the function pointer that was returned by the call to GetAddress("Py_InitModule4") a few paragraphs ago. And... execution jumps to 'Python25Mapper.Py_InitModule4'.

The parameters include the CPython module's name and docstring, and a pointer to its method-names, -docstrings, and -implementations; we use this information to generate Python code which we execute in a new IronPython EngineModule, giving it the appropriate properties (we'll take a look at this code a little bit later). We also create a dictionary mapping function names to delegates, which are themselves created from the function pointers to the actual implementations. This 'DispatchTable' dictionary is stored in the EngineModule's Globals dict, as is a reference to the Python25Mapper object itself.

At this point, the new module is present in the PythonEngine's sys.modules, and it becomes possible to 'import bz2'; however, it still isn't very useful. Anyway, once we have created the new module, we pass it into the Python25Mapper's 'Store' method, which:
* allocates a tiny chunk of memory;
* stores the module in a dictionary, keyed on the pointer we just allocated; and
* returns the pointer.

'Py_InitModule4' then returns that pointer; 'initbz2' checks that the pointer is not NULL, and then uses it as the first parameter to a series of 'PyModule_AddObject' calls. These calls are intercepted in the same way as before, so the parameters are passed up to the Python25Mapper's 'PyModule_AddObject' method. In the interesting cases, the other parameters are a type name and a pointer to a PyTypeObject.

The first parameter is always the pointer we allocated previously; the Python25Mapper's 'PyModule_AddObject' looks up this pointer in the dictionary and retrieves a reference to the real EngineModule, and then executes some more generated code, in that module, to define the new types in such a way that IronPython can use them. Any methods defined on those types are also added to the module's DispatchTable.

Finally, 'PyModule_AddObject' extracts references to the newly defined types, and sets various attributes on them, which are used by the generated code: specifically, these attributes are (1) a pointer to the PyTypeObject ('_typePtr') and (2) delegates pointing to the C functions which create ('_tp_newDgt') and initialise ('_tp_initDgt') instances of the type.

At this point, we can start doing interesting things with the module; to understand these, it will be useful to see (a representative sample of) the code that has been executed in the new module:

------------------------------------------------------------------------------------------------

from System import IntPtr

def _cleanup(*args):
    _ironclad_mapper.FreeTemps()
    for arg in args:
        if arg != IntPtr.Zero:
            _ironclad_mapper.DecRef(arg)

def _raiseExceptionIfRequired():
    error = _ironclad_mapper.LastException
    if error:
        _ironclad_mapper.LastException = None
        raise error

...

def _ironclad_dispatch_kwargs(name, instancePtr, args, kwargs):
    argPtr = _ironclad_mapper.Store(args)
    kwargPtr = _ironclad_mapper.Store(kwargs)
    resultPtr = _ironclad_dispatch_table[name](instancePtr, argPtr, kwargPtr)
    try:
        _raiseExceptionIfRequired()
        return _ironclad_mapper.Retrieve(resultPtr)
    finally:
        _cleanup(argPtr, kwargPtr, resultPtr)
------------------------------------------------------------------------------------------------

The code just above is always included, and does most of the critical work. The '_ironclad_mapper' is the Python25Mapper that created the module, and the '_ironclad_dispatch_table' is a dictionary mapping function names to their C implementations (or rather, to delegates which point to the C implementations).

The only dispatch function shown here ('_ironclad_dispatch_kwargs') is the most complex of the three currently implemented; the other two ('_ironclad_dispatch' and '_ironclad_dispatch_noargs') are fundamentally similar. We'll describe how it actually works when we finally call 'bz2.compress' -- soon, I promise.

------------------------------------------------------------------------------------------------
def compress(*args, **kwargs):
    '''compress(data [, compresslevel=9]) -> string

Compress data in one shot. If you want to compress data sequentially,
use an instance of BZ2Compressor instead. The compresslevel parameter, if
given, must be a number between 1 and 9.
'''
    return _ironclad_dispatch_kwargs('compress', IntPtr.Zero, args, kwargs)
------------------------------------------------------------------------------------------------

The definition of the 'compress' function, above, was generated from the name and docstring in the PyMethodDef structure passed into 'Py_InitModule4'. So, what happens when we actually call it?

First of all, '_ironclad_dispatch_kwargs' gets pointers to the args and kwargs by passing them into the Python25Mapper's 'Store' method. As discussed previously, this method allocates a tiny bit of memory and maps it to the real object so we can retrieve the real object again when we need it. It should be noted that, at present, 'Store' creates opaque pointers which don't hold any real data apart from a refcount; this approach will not be viable in the long term, but it's good enough for now (and in many cases, all we'll ever need to store will be a refcount and a type pointer).

Then, it looks up the C function's delegate in the '_ironclad_dispatch_table' dictionary, and passes the newly-created pointers to the delegate; this then calls the 'bz2_compress' C function. The C function immediately calls back into managed code, passing argPtr and kwargPtr, plus a series of pointers to local data, up to 'Python25Mapper.PyArg_ParseTupleAndKeywords'.

Note: 'PyArg_ParseTupleAndKeywords' is a little bit magical, and works slightly differently from other calls into managed code. However, the current approach is rather stupid and wasteful of developer time, so we're planning to replace it as soon as possible. Therefore, I feel justified in eliding the details: basically, it retrieves the original 'args' and 'kwargs' parameters and writes appropriate values into the extra pointers passed up by 'bz2_compress'.

Once 'PyArg_ParseTupleAndKeywords' returns, 'bz2_compress' has access to all its arguments in a format it can do real work with. I don't know what it's really doing under the hood; from our perspective, the only really important thing is that it creates a PyStringObject by calling 'PyString_FromStringAndSize', and eventually returns a pointer to that PyStringObject.

This PyString object, unlike everything else we've seen so far, makes a semi-serious attempt at impersonating a real PyStringObject: we actually lay the memory out correctly and put the character data in the right place. This is necessary because the function uses the PyString_AS_STRING macro, which returns a pointer to that character data, into which 'bz2compress' writes the compressed bytes.

Also, since the managed code doesn't know the string contents until 'bz2compress' has finished writing it, it doesn't create a managed string yet: rather, it maps the string pointer to an 'UnmanagedDataMarker.PyStringObject'. Once 'bz2compress' finally returns, '_ironclad_dispatch_kwargs' receives a pointer to the PyStringObject; when we 'Retrieve' the managed object from the Python25Mapper, it reads in the character data and replaces the marker in the pointer map before returning the actual managed string -- which is at last returned to the IronPython code which made the call to 'compress' in the first place.

Had anything gone wrong in the above process, a call to 'PyErr_SetString' would have set an exception on the Python25Mapper object; if the mapper's LastException property is non-None, we raise the exception and clear the property. We also ensure that we decref argPtr, kwargPtr, and resultPtr before we return, to avoid leaking memory.

Phew. Now, let's look at the 'BZ2Compressor' type. Thankfully, given the context we have already built up, this should be relatively easy to describe. Here's the code generated by the 'PyModule_AddObject' call which set it up:

------------------------------------------------------------------------------------------------
class BZ2Compressor(object):
    __module__ = 'bz2'
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)
        argPtr = _ironclad_mapper.Store(args)
        kwargPtr = _ironclad_mapper.Store(kwargs)
        try:
            instancePtr = cls._tp_newDgt(cls._typePtr, argPtr, kwargPtr)
            _raiseExceptionIfRequired()
        finally:
            _cleanup(argPtr, kwargPtr)

        _ironclad_mapper.StoreUnmanagedData(instancePtr, instance)
        instance._instancePtr = instancePtr
        return instance

    def __init__(self, *args, **kwargs):
        object.__init__(self)
        argPtr = _ironclad_mapper.Store(args)
        kwargPtr = _ironclad_mapper.Store(kwargs)
        try:
            result = self.__class__._tp_initDgt(self._instancePtr, argPtr, kwargPtr)
            if result == -1:
                _ironclad_mapper.DecRef(self._instancePtr)
            _raiseExceptionIfRequired()
        finally:
            _cleanup(argPtr, kwargPtr)

    def compress(self, *args):
        '''compress(data) -> string

Provide more data to the compressor object. It will return chunks of
compressed data whenever possible. When you've finished providing data
to compress, call the flush() method to finish the compression process,
and return what is left in the internal buffers.
'''
        return _ironclad_dispatch('BZ2Compressor.compress', self._instancePtr, args)

    def flush(self):
        '''flush() -> string

Finish the compression process and return what is left in internal buffers.
You must not use the compressor object after calling this method.
'''
        return _ironclad_dispatch_noargs('BZ2Compressor.flush', self._instancePtr)

BZ2Compressor.__name__ = 'BZ2Compressor'
------------------------------------------------------------------------------------------------

The first thing to note is that the methods use the same dispatch functions as regular function calls, but where functions pass IntPtr.Zero, methods pass an actual instance pointer. Getting that instance pointer in the first place is slightly more interesting.

When you instantiate a BZ2Compressor, the __new__ method calls the CPython type's 'tp_new' function (via a delegate, with exception checking and parameter cleanup, as usual). As long as this function doesn't set an exception, we use 'StoreUnmanagedData' to set up the mapping in the Python25Mapper, give the instance a reference to the unmanaged memory backing it, and return the real managed object. 'StoreUnmanagedData' is just like 'Store' -- it causes the Python25Mapper to remember the relationship between the pointer and the object -- but it's used in cases where the unmanaged memory has already been allocated.

Similarly, the __init__ method calls the CPython type's 'tp_init' function in the usual fashion, passing in the recently-created instance pointer. The only potentially surprising feature is that, on failure, we decref the instance pointer; we suspect that this may cause problems if exceptions are raised when the same object is repeatedly initialised, but we've resolved not to worry about this for now.

We don't yet handle object deletion.

