

The easiest way to explain PROJECTNAME's inner workings is to follow the code as we import and use the bz2 module; the following code is lightly adapted from 'functionalitytest.py'.

------------------------------------------------------------------------------------------------
engine = PythonEngine()
mapper = Python25Mapper(engine)
sr = StubReference("python25.dll")
try:
	sr.Init(AddressGetterDelegate(mapper.GetAddress), DataSetterDelegate(mapper.SetData))
	pi = PydImporter()
	pi.Load("C:\\Python25\\Dlls\\bz2.pyd")
	try:
		engine.Execute("import bz2")
		engine.Execute("print bz2.compress('heaps and heaps of data ' * 200)")
	finally:
		pi.Dispose()
finally:
	sr.Dispose()
------------------------------------------------------------------------------------------------

The first 2 lines require little explanation -- we create an IronPython PythonEngine and a PROJECTNAME Python25Mapper, and give the latter a reference to the former. On the 3rd line, things start to get interesting.

------------------------------------------------------------------------------------------------
sr = StubReference("python25.dll")
------------------------------------------------------------------------------------------------

We pass the StubReference the path to our autogenerated stub library. This library exports all the symbols exported by the real python25 library, and has the same name; once we've loaded it, our process space contains a library that looks very much like the real python25. As yet, it contains very little of value -- any function calls or attempts to access data will almost certainly crash. To make it useful, we need to initialise it:

------------------------------------------------------------------------------------------------
	sr.Init(AddressGetterDelegate(mapper.GetAddress), DataSetterDelegate(mapper.SetData))
------------------------------------------------------------------------------------------------

The 'Init' method takes a pair of Delegates, converts them to function pointers, and passes them into the stub python25's 'init' function.

'GetAddress' is defined in the autogenerated PythonMapper class; it takes a symbol (as a string) and returns a function pointer. This function pointer comes from a delegate of the appropriate type, which itself delegates to the real managed implementation of that function (that is, a method on the PythonMapper instance). The delegate is stored, to avoid embarrassing garbage collections and consequent crashes.

'SetData', also in the autogenerated PythonMapper, takes a symbol and an address, and calls a method on the PythonMapper which will write data into that address; this is primarily for Py*_Types, which are exported as blocks of static data (rather than pointers).

The stub python25's 'init' function calls either GetAddress or SetData for every symbol; how it chooses depends on the contents of the 'overrides' directory, from which it was itself autogenerated. The details re not directly relevant to this discussion; if you're interested, read 'stubmaker.py'.

Once the 'init' function returns, the stub library is ready for duty.

------------------------------------------------------------------------------------------------
	pi = PydImporter()
	pi.Load("C:\\Python25\\Dlls\\bz2.pyd")
------------------------------------------------------------------------------------------------

'PydImporter.Load' loads a library into the process space, and calls the appropriate initialisation function (which is always called 'init[modulename]'). Before we get into the details of what happens now, note that we keep a reference to the PydImporter, so it doesn't get garbage collected until we're ready: the Dispose method will unload any libraries it has imported.

When we call bz2.pyd's 'initbz2' function, it (almost immediately) calls the C 'Py_InitModule4' function. Because the process space already has a library called 'python25' containing the symbol 'Py_InitModule4', the code located at that symbol is executed. This code is a single jmp instruction, leading to the function pointer that was returned by the call to GetAddress("Py_InitModule4") a few paragraphs ago. And... execution jumps to 'Python25Mapper.Py_InitModule4'.

The parameters include the CPython module's name and docstring, and a pointer to its method-names, -docstrings, and -implementations; we use this information to generate Python code which we execute in a new IronPython EngineModule, giving it the appropriate properties (we'll take a look at this code a little bit later). We also create a dictionary mapping function names to delegates, which are themselves created from the function pointers to the actual implementations. This 'DispatchTable' dictionary is stored in the EngineModule's Globals dict, as is a reference to the Python25Mapper object itself.

At this point, the new module is present in the PythonEngine's sys.modules, and it becomes possible to 'import bz2'. Anyway, once we have created the new module, we pass it into the Python25Mapper's 'Store' method, which:
* allocates a tiny chunk of memory,
* stores the module in a dictionary, keyed on the pointer we just allocated, and
* returns the pointer.

'Py_InitModule4' then returns that pointer; 'initbz2' checks that the pointer is not NULL, and then uses it as the first parameter to a series of 'PyModule_AddObject' calls. These calls are intercepted in the same way as before, so the parameters are passed up to the Python25Mapper's 'PyModule_AddObject' method. In the interesting cases, the other parameters are a type name and a pointer to a PyTypeObject.

The first parameter is always the pointer we allocated previously; the Python25Mapper's 'PyModule_AddObject' looks up this pointer in the dictionary and retrieves a reference to the real EngineModule, and then executes more generated code, in that module, to define the new types in such a way that IronPython can use them. Any methods defined on those types are also added to the module's DispatchTable.

Finally, 'PyModule_AddObject' extracts references to the newly defined types, and sets various attributes on them, which are used by the generated code: specifically, these attributes are (1) a pointer to the PyTypeObject and (2) delegates pointing to the C functions which create ('_tp_newDgt') and ('_tp_initDgt') instances of the type.

At this point, we can start doing interesting things with the module; to understand these, it will be useful to see (a representative sample of) the code that has been executed in the new module up to this point:

------------------------------------------------------------------------------------------------

from System import IntPtr

def _cleanup(*args):
    _jumpy_mapper.FreeTemps()
    for arg in args:
        if arg != IntPtr.Zero:
            _jumpy_mapper.DecRef(arg)

def _raiseExceptionIfRequired():
    error = _jumpy_mapper.LastException
    if error:
        _jumpy_mapper.LastException = None
        raise error

def _jumpy_dispatch(name, instancePtr, args):
    argPtr = _jumpy_mapper.Store(args)
    resultPtr = _jumpy_dispatch_table[name](instancePtr, argPtr)
    try:
        _raiseExceptionIfRequired()
        return _jumpy_mapper.Retrieve(resultPtr)
    finally:
        _cleanup(argPtr, resultPtr)

def _jumpy_dispatch_noargs(name, instancePtr):
    resultPtr = _jumpy_dispatch_table[name](instancePtr, IntPtr.Zero)
    try:
        _raiseExceptionIfRequired()
        return _jumpy_mapper.Retrieve(resultPtr)
    finally:
        _cleanup(resultPtr)

def _jumpy_dispatch_kwargs(name, instancePtr, args, kwargs):
    argPtr = _jumpy_mapper.Store(args)
    kwargPtr = _jumpy_mapper.Store(kwargs)
    resultPtr = _jumpy_dispatch_table[name](instancePtr, argPtr, kwargPtr)
    try:
        _raiseExceptionIfRequired()
        return _jumpy_mapper.Retrieve(resultPtr)
    finally:
        _cleanup(argPtr, kwargPtr, resultPtr)


def compress(*args, **kwargs):
    '''compress(data [, compresslevel=9]) -> string

Compress data in one shot. If you want to compress data sequentially,
use an instance of BZ2Compressor instead. The compresslevel parameter, if
given, must be a number between 1 and 9.
'''
    return _jumpy_dispatch_kwargs('compress', IntPtr.Zero, args, kwargs)

def decompress(*args):
    '''decompress(data) -> decompressed data

Decompress data in one shot. If you want to decompress data sequentially,
use an instance of BZ2Decompressor instead.
'''
    return _jumpy_dispatch('decompress', IntPtr.Zero, args)


class BZ2Compressor(object):
    __module__ = 'bz2'
    def __new__(cls, *args, **kwargs):
        instance = object.__new__(cls)
        argPtr = _jumpy_mapper.Store(args)
        kwargPtr = _jumpy_mapper.Store(kwargs)
        instancePtr = cls._tp_newDgt(cls._typePtr, argPtr, kwargPtr)
        _cleanup(argPtr, kwargPtr)

        _jumpy_mapper.StoreUnmanagedData(instancePtr, instance)
        instance._instancePtr = instancePtr
        return instance

    def __init__(self, *args, **kwargs):
        object.__init__(self)
        argPtr = _jumpy_mapper.Store(args)
        kwargPtr = _jumpy_mapper.Store(kwargs)
        self.__class__._tp_initDgt(self._instancePtr, argPtr, kwargPtr)
        _cleanup(argPtr, kwargPtr)

    def compress(self, *args):
        '''compress(data) -> string

Provide more data to the compressor object. It will return chunks of
compressed data whenever possible. When you've finished providing data
to compress, call the flush() method to finish the compression process,
and return what is left in the internal buffers.
'''
        return _jumpy_dispatch('BZ2Compressor.compress', self._instancePtr, args)

    def flush(self):
        '''flush() -> string

Finish the compression process and return what is left in internal buffers.
You must not use the compressor object after calling this method.
'''
        return _jumpy_dispatch_noargs('BZ2Compressor.flush', self._instancePtr)

BZ2Compressor.__name__ = 'BZ2Compressor'

------------------------------------------------------------------------------------------------

